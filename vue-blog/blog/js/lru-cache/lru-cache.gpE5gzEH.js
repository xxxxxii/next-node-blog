var t,i,e,s,h,l,n,o,a,r,c,u,f,d,p,g,w,v,_,S,b,m,y,A,O,W,F,E,z,T,k,M,C,x,R,D,L,G,U,j,N,I,H,P,B=Object.defineProperty,q=t=>{throw TypeError(t)},V=(t,i,e)=>((t,i,e)=>i in t?B(t,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[i]=e)(t,"symbol"!=typeof i?i+"":i,e),X=(t,i,e)=>i.has(t)||q("Cannot "+e),Y=(t,i,e)=>(X(t,i,"read from private field"),e?e.call(t):i.get(t)),J=(t,i,e)=>i.has(t)?q("Cannot add the same private member more than once"):i instanceof WeakSet?i.add(t):i.set(t,e),K=(t,i,e,s)=>(X(t,i,"write to private field"),s?s.call(t,e):i.set(t,e),e),Q=(t,i,e)=>(X(t,i,"access private method"),e),Z=(t,i,e,s)=>({set _(s){K(t,i,s,e)},get _(){return Y(t,i,s)}});const $="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,tt=new Set,it="object"==typeof process&&process?process:{},et=(t,i,e,s)=>{"function"==typeof it.emitWarning&&it.emitWarning(t,i,e,s)};let st=globalThis.AbortController,ht=globalThis.AbortSignal;if(void 0===st){ht=class{constructor(){V(this,"onabort"),V(this,"_onabort",[]),V(this,"reason"),V(this,"aborted",!1)}addEventListener(t,i){this._onabort.push(i)}},st=class{constructor(){V(this,"signal",new ht),e()}abort(t){var i,e;if(!this.signal.aborted){this.signal.reason=t,this.signal.aborted=!0;for(const i of this.signal._onabort)i(t);null==(e=(i=this.signal).onabort)||e.call(i,t)}}};let i="1"!==(null==(t=it.env)?void 0:t.LRU_CACHE_IGNORE_AC_WARNING);const e=()=>{i&&(i=!1,et("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}const lt=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),nt=t=>lt(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?ot:null:null;class ot extends Array{constructor(t){super(t),this.fill(0)}}const at=class t{constructor(e,s){if(V(this,"heap"),V(this,"length"),!Y(t,i))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new s(e),this.length=0}static create(e){const s=nt(e);if(!s)return[];K(t,i,!0);const h=new t(e,s);return K(t,i,!1),h}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}};i=new WeakMap,J(at,i,!1);let rt=at;const ct=class t{constructor(i){J(this,F),J(this,h),J(this,l),J(this,n),J(this,o),J(this,a),V(this,"ttl"),V(this,"ttlResolution"),V(this,"ttlAutopurge"),V(this,"updateAgeOnGet"),V(this,"updateAgeOnHas"),V(this,"allowStale"),V(this,"noDisposeOnSet"),V(this,"noUpdateTTL"),V(this,"maxEntrySize"),V(this,"sizeCalculation"),V(this,"noDeleteOnFetchRejection"),V(this,"noDeleteOnStaleGet"),V(this,"allowStaleOnFetchAbort"),V(this,"allowStaleOnFetchRejection"),V(this,"ignoreFetchAbort"),J(this,r),J(this,c),J(this,u),J(this,f),J(this,d),J(this,p),J(this,g),J(this,w),J(this,v),J(this,_),J(this,S),J(this,b),J(this,m),J(this,y),J(this,A),J(this,O),J(this,W),J(this,z,(()=>{})),J(this,T,(()=>{})),J(this,k,(()=>{})),J(this,M,(()=>!1)),J(this,x,(t=>{})),J(this,R,((t,i,e)=>{})),J(this,D,((t,i,e,s)=>{if(e||s)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0})),V(this,e,"LRUCache");const{max:s=0,ttl:L,ttlResolution:G=1,ttlAutopurge:U,updateAgeOnGet:j,updateAgeOnHas:N,allowStale:I,dispose:H,disposeAfter:P,noDisposeOnSet:B,noUpdateTTL:q,maxSize:X=0,maxEntrySize:Z=0,sizeCalculation:$,fetchMethod:it,noDeleteOnFetchRejection:st,noDeleteOnStaleGet:ht,allowStaleOnFetchRejection:ot,allowStaleOnFetchAbort:at,ignoreFetchAbort:ct}=i;if(0!==s&&!lt(s))throw new TypeError("max option must be a nonnegative integer");const ut=s?nt(s):Array;if(!ut)throw new Error("invalid max value: "+s);if(K(this,h,s),K(this,l,X),this.maxEntrySize=Z||Y(this,l),this.sizeCalculation=$,this.sizeCalculation){if(!Y(this,l)&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw new TypeError("sizeCalculation set to non-function")}if(void 0!==it&&"function"!=typeof it)throw new TypeError("fetchMethod must be a function if specified");if(K(this,a,it),K(this,O,!!it),K(this,u,new Map),K(this,f,new Array(s).fill(void 0)),K(this,d,new Array(s).fill(void 0)),K(this,p,new ut(s)),K(this,g,new ut(s)),K(this,w,0),K(this,v,0),K(this,_,rt.create(s)),K(this,r,0),K(this,c,0),"function"==typeof H&&K(this,n,H),"function"==typeof P?(K(this,o,P),K(this,S,[])):(K(this,o,void 0),K(this,S,void 0)),K(this,A,!!Y(this,n)),K(this,W,!!Y(this,o)),this.noDisposeOnSet=!!B,this.noUpdateTTL=!!q,this.noDeleteOnFetchRejection=!!st,this.allowStaleOnFetchRejection=!!ot,this.allowStaleOnFetchAbort=!!at,this.ignoreFetchAbort=!!ct,0!==this.maxEntrySize){if(0!==Y(this,l)&&!lt(Y(this,l)))throw new TypeError("maxSize must be a positive integer if specified");if(!lt(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");Q(this,F,C).call(this)}if(this.allowStale=!!I,this.noDeleteOnStaleGet=!!ht,this.updateAgeOnGet=!!j,this.updateAgeOnHas=!!N,this.ttlResolution=lt(G)||0===G?G:1,this.ttlAutopurge=!!U,this.ttl=L||0,this.ttl){if(!lt(this.ttl))throw new TypeError("ttl must be a positive integer if specified");Q(this,F,E).call(this)}if(0===Y(this,h)&&0===this.ttl&&0===Y(this,l))throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!Y(this,h)&&!Y(this,l)){const i="LRU_CACHE_UNBOUNDED";if((t=>!tt.has(t))(i)){tt.add(i);et("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",i,t)}}}static unsafeExposeInternals(t){return{starts:Y(t,m),ttls:Y(t,y),sizes:Y(t,b),keyMap:Y(t,u),keyList:Y(t,f),valList:Y(t,d),next:Y(t,p),prev:Y(t,g),get head(){return Y(t,w)},get tail(){return Y(t,v)},free:Y(t,_),isBackgroundFetch:i=>{var e;return Q(e=t,F,I).call(e,i)},backgroundFetch:(i,e,s,h)=>{var l;return Q(l=t,F,N).call(l,i,e,s,h)},moveToTail:i=>{var e;return Q(e=t,F,P).call(e,i)},indexes:i=>{var e;return Q(e=t,F,L).call(e,i)},rindexes:i=>{var e;return Q(e=t,F,G).call(e,i)},isStale:i=>{var e;return Y(e=t,M).call(e,i)}}}get max(){return Y(this,h)}get maxSize(){return Y(this,l)}get calculatedSize(){return Y(this,c)}get size(){return Y(this,r)}get fetchMethod(){return Y(this,a)}get dispose(){return Y(this,n)}get disposeAfter(){return Y(this,o)}getRemainingTTL(t){return Y(this,u).has(t)?1/0:0}*entries(){for(const t of Q(this,F,L).call(this))void 0===Y(this,d)[t]||void 0===Y(this,f)[t]||Q(this,F,I).call(this,Y(this,d)[t])||(yield[Y(this,f)[t],Y(this,d)[t]])}*rentries(){for(const t of Q(this,F,G).call(this))void 0===Y(this,d)[t]||void 0===Y(this,f)[t]||Q(this,F,I).call(this,Y(this,d)[t])||(yield[Y(this,f)[t],Y(this,d)[t]])}*keys(){for(const t of Q(this,F,L).call(this)){const i=Y(this,f)[t];void 0===i||Q(this,F,I).call(this,Y(this,d)[t])||(yield i)}}*rkeys(){for(const t of Q(this,F,G).call(this)){const i=Y(this,f)[t];void 0===i||Q(this,F,I).call(this,Y(this,d)[t])||(yield i)}}*values(){for(const t of Q(this,F,L).call(this)){void 0===Y(this,d)[t]||Q(this,F,I).call(this,Y(this,d)[t])||(yield Y(this,d)[t])}}*rvalues(){for(const t of Q(this,F,G).call(this)){void 0===Y(this,d)[t]||Q(this,F,I).call(this,Y(this,d)[t])||(yield Y(this,d)[t])}}[(s=Symbol.iterator,e=Symbol.toStringTag,s)](){return this.entries()}find(t,i={}){for(const e of Q(this,F,L).call(this)){const s=Y(this,d)[e],h=Q(this,F,I).call(this,s)?s.__staleWhileFetching:s;if(void 0!==h&&t(h,Y(this,f)[e],this))return this.get(Y(this,f)[e],i)}}forEach(t,i=this){for(const e of Q(this,F,L).call(this)){const s=Y(this,d)[e],h=Q(this,F,I).call(this,s)?s.__staleWhileFetching:s;void 0!==h&&t.call(i,h,Y(this,f)[e],this)}}rforEach(t,i=this){for(const e of Q(this,F,G).call(this)){const s=Y(this,d)[e],h=Q(this,F,I).call(this,s)?s.__staleWhileFetching:s;void 0!==h&&t.call(i,h,Y(this,f)[e],this)}}purgeStale(){let t=!1;for(const i of Q(this,F,G).call(this,{allowStale:!0}))Y(this,M).call(this,i)&&(this.delete(Y(this,f)[i]),t=!0);return t}info(t){const i=Y(this,u).get(t);if(void 0===i)return;const e=Y(this,d)[i],s=Q(this,F,I).call(this,e)?e.__staleWhileFetching:e;if(void 0===s)return;const h={value:s};if(Y(this,y)&&Y(this,m)){const t=Y(this,y)[i],e=Y(this,m)[i];if(t&&e){const i=t-($.now()-e);h.ttl=i,h.start=Date.now()}}return Y(this,b)&&(h.size=Y(this,b)[i]),h}dump(){const t=[];for(const i of Q(this,F,L).call(this,{allowStale:!0})){const e=Y(this,f)[i],s=Y(this,d)[i],h=Q(this,F,I).call(this,s)?s.__staleWhileFetching:s;if(void 0===h||void 0===e)continue;const l={value:h};if(Y(this,y)&&Y(this,m)){l.ttl=Y(this,y)[i];const t=$.now()-Y(this,m)[i];l.start=Math.floor(Date.now()-t)}Y(this,b)&&(l.size=Y(this,b)[i]),t.unshift([e,l])}return t}load(t){this.clear();for(const[i,e]of t){if(e.start){const t=Date.now()-e.start;e.start=$.now()-t}this.set(i,e.value,e)}}set(t,i,e={}){var s,l,a,c,w;if(void 0===i)return this.delete(t),this;const{ttl:b=this.ttl,start:m,noDisposeOnSet:z=this.noDisposeOnSet,sizeCalculation:M=this.sizeCalculation,status:C}=e;let{noUpdateTTL:L=this.noUpdateTTL}=e;const G=Y(this,D).call(this,t,i,e.size||0,M);if(this.maxEntrySize&&G>this.maxEntrySize)return C&&(C.set="miss",C.maxEntrySizeExceeded=!0),this.delete(t),this;let U=0===Y(this,r)?void 0:Y(this,u).get(t);if(void 0===U)U=0===Y(this,r)?Y(this,v):0!==Y(this,_).length?Y(this,_).pop():Y(this,r)===Y(this,h)?Q(this,F,j).call(this,!1):Y(this,r),Y(this,f)[U]=t,Y(this,d)[U]=i,Y(this,u).set(t,U),Y(this,p)[Y(this,v)]=U,Y(this,g)[U]=Y(this,v),K(this,v,U),Z(this,r)._++,Y(this,R).call(this,U,G,C),C&&(C.set="add"),L=!1;else{Q(this,F,P).call(this,U);const e=Y(this,d)[U];if(i!==e){if(Y(this,O)&&Q(this,F,I).call(this,e)){e.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:i}=e;void 0===i||z||(Y(this,A)&&(null==(s=Y(this,n))||s.call(this,i,t,"set")),Y(this,W)&&(null==(l=Y(this,S))||l.push([i,t,"set"])))}else z||(Y(this,A)&&(null==(a=Y(this,n))||a.call(this,e,t,"set")),Y(this,W)&&(null==(c=Y(this,S))||c.push([e,t,"set"])));if(Y(this,x).call(this,U),Y(this,R).call(this,U,G,C),Y(this,d)[U]=i,C){C.set="replace";const t=e&&Q(this,F,I).call(this,e)?e.__staleWhileFetching:e;void 0!==t&&(C.oldValue=t)}}else C&&(C.set="update")}if(0===b||Y(this,y)||Q(this,F,E).call(this),Y(this,y)&&(L||Y(this,k).call(this,U,b,m),C&&Y(this,T).call(this,C,U)),!z&&Y(this,W)&&Y(this,S)){const t=Y(this,S);let i;for(;i=null==t?void 0:t.shift();)null==(w=Y(this,o))||w.call(this,...i)}return this}pop(){var t;try{for(;Y(this,r);){const t=Y(this,d)[Y(this,w)];if(Q(this,F,j).call(this,!0),Q(this,F,I).call(this,t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(void 0!==t)return t}}finally{if(Y(this,W)&&Y(this,S)){const i=Y(this,S);let e;for(;e=null==i?void 0:i.shift();)null==(t=Y(this,o))||t.call(this,...e)}}}has(t,i={}){const{updateAgeOnHas:e=this.updateAgeOnHas,status:s}=i,h=Y(this,u).get(t);if(void 0!==h){const t=Y(this,d)[h];if(Q(this,F,I).call(this,t)&&void 0===t.__staleWhileFetching)return!1;if(!Y(this,M).call(this,h))return e&&Y(this,z).call(this,h),s&&(s.has="hit",Y(this,T).call(this,s,h)),!0;s&&(s.has="stale",Y(this,T).call(this,s,h))}else s&&(s.has="miss");return!1}peek(t,i={}){const{allowStale:e=this.allowStale}=i,s=Y(this,u).get(t);if(void 0===s||!e&&Y(this,M).call(this,s))return;const h=Y(this,d)[s];return Q(this,F,I).call(this,h)?h.__staleWhileFetching:h}async fetch(t,i={}){const{allowStale:e=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,ttl:l=this.ttl,noDisposeOnSet:n=this.noDisposeOnSet,size:o=0,sizeCalculation:a=this.sizeCalculation,noUpdateTTL:r=this.noUpdateTTL,noDeleteOnFetchRejection:c=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:f=this.allowStaleOnFetchRejection,ignoreFetchAbort:p=this.ignoreFetchAbort,allowStaleOnFetchAbort:g=this.allowStaleOnFetchAbort,context:w,forceRefresh:v=!1,status:_,signal:S}=i;if(!Y(this,O))return _&&(_.fetch="get"),this.get(t,{allowStale:e,updateAgeOnGet:s,noDeleteOnStaleGet:h,status:_});const b={allowStale:e,updateAgeOnGet:s,noDeleteOnStaleGet:h,ttl:l,noDisposeOnSet:n,size:o,sizeCalculation:a,noUpdateTTL:r,noDeleteOnFetchRejection:c,allowStaleOnFetchRejection:f,allowStaleOnFetchAbort:g,ignoreFetchAbort:p,status:_,signal:S};let m=Y(this,u).get(t);if(void 0===m){_&&(_.fetch="miss");const i=Q(this,F,N).call(this,t,m,b,w);return i.__returned=i}{const i=Y(this,d)[m];if(Q(this,F,I).call(this,i)){const t=e&&void 0!==i.__staleWhileFetching;return _&&(_.fetch="inflight",t&&(_.returnedStale=!0)),t?i.__staleWhileFetching:i.__returned=i}const h=Y(this,M).call(this,m);if(!v&&!h)return _&&(_.fetch="hit"),Q(this,F,P).call(this,m),s&&Y(this,z).call(this,m),_&&Y(this,T).call(this,_,m),i;const l=Q(this,F,N).call(this,t,m,b,w),n=void 0!==l.__staleWhileFetching&&e;return _&&(_.fetch=h?"stale":"refresh",n&&h&&(_.returnedStale=!0)),n?l.__staleWhileFetching:l.__returned=l}}get(t,i={}){const{allowStale:e=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,status:l}=i,n=Y(this,u).get(t);if(void 0!==n){const i=Y(this,d)[n],o=Q(this,F,I).call(this,i);return l&&Y(this,T).call(this,l,n),Y(this,M).call(this,n)?(l&&(l.get="stale"),o?(l&&e&&void 0!==i.__staleWhileFetching&&(l.returnedStale=!0),e?i.__staleWhileFetching:void 0):(h||this.delete(t),l&&e&&(l.returnedStale=!0),e?i:void 0)):(l&&(l.get="hit"),o?i.__staleWhileFetching:(Q(this,F,P).call(this,n),s&&Y(this,z).call(this,n),i))}l&&(l.get="miss")}delete(t){var i,e,s,h;let l=!1;if(0!==Y(this,r)){const s=Y(this,u).get(t);if(void 0!==s)if(l=!0,1===Y(this,r))this.clear();else{Y(this,x).call(this,s);const h=Y(this,d)[s];if(Q(this,F,I).call(this,h)?h.__abortController.abort(new Error("deleted")):(Y(this,A)||Y(this,W))&&(Y(this,A)&&(null==(i=Y(this,n))||i.call(this,h,t,"delete")),Y(this,W)&&(null==(e=Y(this,S))||e.push([h,t,"delete"]))),Y(this,u).delete(t),Y(this,f)[s]=void 0,Y(this,d)[s]=void 0,s===Y(this,v))K(this,v,Y(this,g)[s]);else if(s===Y(this,w))K(this,w,Y(this,p)[s]);else{const t=Y(this,g)[s];Y(this,p)[t]=Y(this,p)[s];const i=Y(this,p)[s];Y(this,g)[i]=Y(this,g)[s]}Z(this,r)._--,Y(this,_).push(s)}}if(Y(this,W)&&(null==(s=Y(this,S))?void 0:s.length)){const t=Y(this,S);let i;for(;i=null==t?void 0:t.shift();)null==(h=Y(this,o))||h.call(this,...i)}return l}clear(){var t,i,e;for(const s of Q(this,F,G).call(this,{allowStale:!0})){const e=Y(this,d)[s];if(Q(this,F,I).call(this,e))e.__abortController.abort(new Error("deleted"));else{const h=Y(this,f)[s];Y(this,A)&&(null==(t=Y(this,n))||t.call(this,e,h,"delete")),Y(this,W)&&(null==(i=Y(this,S))||i.push([e,h,"delete"]))}}if(Y(this,u).clear(),Y(this,d).fill(void 0),Y(this,f).fill(void 0),Y(this,y)&&Y(this,m)&&(Y(this,y).fill(0),Y(this,m).fill(0)),Y(this,b)&&Y(this,b).fill(0),K(this,w,0),K(this,v,0),Y(this,_).length=0,K(this,c,0),K(this,r,0),Y(this,W)&&Y(this,S)){const t=Y(this,S);let i;for(;i=null==t?void 0:t.shift();)null==(e=Y(this,o))||e.call(this,...i)}}};h=new WeakMap,l=new WeakMap,n=new WeakMap,o=new WeakMap,a=new WeakMap,r=new WeakMap,c=new WeakMap,u=new WeakMap,f=new WeakMap,d=new WeakMap,p=new WeakMap,g=new WeakMap,w=new WeakMap,v=new WeakMap,_=new WeakMap,S=new WeakMap,b=new WeakMap,m=new WeakMap,y=new WeakMap,A=new WeakMap,O=new WeakMap,W=new WeakMap,F=new WeakSet,E=function(){const t=new ot(Y(this,h)),i=new ot(Y(this,h));K(this,y,t),K(this,m,i),K(this,k,((e,s,h=$.now())=>{if(i[e]=0!==s?h:0,t[e]=s,0!==s&&this.ttlAutopurge){const t=setTimeout((()=>{Y(this,M).call(this,e)&&this.delete(Y(this,f)[e])}),s+1);t.unref&&t.unref()}})),K(this,z,(e=>{i[e]=0!==t[e]?$.now():0})),K(this,T,((h,l)=>{if(t[l]){const n=t[l],o=i[l];if(!n||!o)return;h.ttl=n,h.start=o,h.now=e||s();const a=h.now-o;h.remainingTTL=n-a}}));let e=0;const s=()=>{const t=$.now();if(this.ttlResolution>0){e=t;const i=setTimeout((()=>e=0),this.ttlResolution);i.unref&&i.unref()}return t};this.getRemainingTTL=h=>{const l=Y(this,u).get(h);if(void 0===l)return 0;const n=t[l],o=i[l];if(!n||!o)return 1/0;return n-((e||s())-o)},K(this,M,(h=>{const l=i[h],n=t[h];return!!n&&!!l&&(e||s())-l>n}))},z=new WeakMap,T=new WeakMap,k=new WeakMap,M=new WeakMap,C=function(){const t=new ot(Y(this,h));K(this,c,0),K(this,b,t),K(this,x,(i=>{K(this,c,Y(this,c)-t[i]),t[i]=0})),K(this,D,((t,i,e,s)=>{if(Q(this,F,I).call(this,i))return 0;if(!lt(e)){if(!s)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if("function"!=typeof s)throw new TypeError("sizeCalculation must be a function");if(e=s(i,t),!lt(e))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return e})),K(this,R,((i,e,s)=>{if(t[i]=e,Y(this,l)){const e=Y(this,l)-t[i];for(;Y(this,c)>e;)Q(this,F,j).call(this,!0)}K(this,c,Y(this,c)+t[i]),s&&(s.entrySize=e,s.totalCalculatedSize=Y(this,c))}))},x=new WeakMap,R=new WeakMap,D=new WeakMap,L=function*({allowStale:t=this.allowStale}={}){if(Y(this,r))for(let i=Y(this,v);Q(this,F,U).call(this,i)&&(!t&&Y(this,M).call(this,i)||(yield i),i!==Y(this,w));)i=Y(this,g)[i]},G=function*({allowStale:t=this.allowStale}={}){if(Y(this,r))for(let i=Y(this,w);Q(this,F,U).call(this,i)&&(!t&&Y(this,M).call(this,i)||(yield i),i!==Y(this,v));)i=Y(this,p)[i]},U=function(t){return void 0!==t&&Y(this,u).get(Y(this,f)[t])===t},j=function(t){var i,e;const s=Y(this,w),h=Y(this,f)[s],l=Y(this,d)[s];return Y(this,O)&&Q(this,F,I).call(this,l)?l.__abortController.abort(new Error("evicted")):(Y(this,A)||Y(this,W))&&(Y(this,A)&&(null==(i=Y(this,n))||i.call(this,l,h,"evict")),Y(this,W)&&(null==(e=Y(this,S))||e.push([l,h,"evict"]))),Y(this,x).call(this,s),t&&(Y(this,f)[s]=void 0,Y(this,d)[s]=void 0,Y(this,_).push(s)),1===Y(this,r)?(K(this,w,K(this,v,0)),Y(this,_).length=0):K(this,w,Y(this,p)[s]),Y(this,u).delete(h),Z(this,r)._--,s},N=function(t,i,e,s){const h=void 0===i?void 0:Y(this,d)[i];if(Q(this,F,I).call(this,h))return h;const l=new st,{signal:n}=e;null==n||n.addEventListener("abort",(()=>l.abort(n.reason)),{signal:l.signal});const o={signal:l.signal,options:e,context:s},r=(s,h=!1)=>{const{aborted:n}=l.signal,a=e.ignoreFetchAbort&&void 0!==s;if(e.status&&(n&&!h?(e.status.fetchAborted=!0,e.status.fetchError=l.signal.reason,a&&(e.status.fetchAbortIgnored=!0)):e.status.fetchResolved=!0),n&&!a&&!h)return c(l.signal.reason);const r=f;return Y(this,d)[i]===f&&(void 0===s?r.__staleWhileFetching?Y(this,d)[i]=r.__staleWhileFetching:this.delete(t):(e.status&&(e.status.fetchUpdated=!0),this.set(t,s,o.options))),s},c=s=>{const{aborted:h}=l.signal,n=h&&e.allowStaleOnFetchAbort,o=n||e.allowStaleOnFetchRejection,a=o||e.noDeleteOnFetchRejection,r=f;if(Y(this,d)[i]===f){!a||void 0===r.__staleWhileFetching?this.delete(t):n||(Y(this,d)[i]=r.__staleWhileFetching)}if(o)return e.status&&void 0!==r.__staleWhileFetching&&(e.status.returnedStale=!0),r.__staleWhileFetching;if(r.__returned===r)throw s};e.status&&(e.status.fetchDispatched=!0);const f=new Promise(((i,s)=>{var n;const c=null==(n=Y(this,a))?void 0:n.call(this,t,h,o);c&&c instanceof Promise&&c.then((t=>i(void 0===t?void 0:t)),s),l.signal.addEventListener("abort",(()=>{e.ignoreFetchAbort&&!e.allowStaleOnFetchAbort||(i(void 0),e.allowStaleOnFetchAbort&&(i=t=>r(t,!0)))}))})).then(r,(t=>(e.status&&(e.status.fetchRejected=!0,e.status.fetchError=t),c(t)))),p=Object.assign(f,{__abortController:l,__staleWhileFetching:h,__returned:void 0});return void 0===i?(this.set(t,p,{...o.options,status:void 0}),i=Y(this,u).get(t)):Y(this,d)[i]=p,p},I=function(t){if(!Y(this,O))return!1;const i=t;return!!i&&i instanceof Promise&&i.hasOwnProperty("__staleWhileFetching")&&i.__abortController instanceof st},H=function(t,i){Y(this,g)[i]=t,Y(this,p)[t]=i},P=function(t){t!==Y(this,v)&&(t===Y(this,w)?K(this,w,Y(this,p)[t]):Q(this,F,H).call(this,Y(this,g)[t],Y(this,p)[t]),Q(this,F,H).call(this,Y(this,v),t),K(this,v,t))};let ut=ct;export{ut as L};
